function corrected_timestamps=lsl_correct_pupil_timestamps(data)
    %    LSL_CORRECT_PUPIL_TIMESTAMPS - compute time corrected timestamps for
    %    Pupil Labs data acquired with the pupil_lsl plugin in PupilCapture
    %
    %    LSL_CORRECT_PUPIL_TIMESTAMPS uses LSL_CORRECT_LSL_TIMESTAMPS for
    %    correction time delay and drift of the source data.
    %The PupilLabs data however has two other problems to be taken care of:
    %1) PupilLabs data sometimes contains gaps when processing of the raw
    %camera images takes too long.
    %2) LSL timestamps generated by the pupil_lsl plugin in PupilCapture
    %contain a lot of jitter. To eliminate the jitter a least-squares fit is
    %done to find a monotonically rising time stamp series with equidistant
    %values, except for the positions where gaps occur. It is taken care for
    %that the fitted time stamps are never earlier than expected in a causal
    %system.
    %
    % tc=lsl_correct_pupil_timestamps(data) returns the best effort correction
    % for the available timing information in the LSL_DATA in DATA.
    %
    % SEE ALSO: LSL_ESTIMATE_TIMECORRECTION, LSL_CORRECT_LSL_TIMESTAMPS, LSL_DATA,
    % LSL_SESSION, LSL_STREAM
    
    assert(isa(data,'lsl_data'),'type mismatch: expected lsl_pupil_data or derived class.');
    assert(size(data.Data,1)>=5, 'data is probably not pupil_data');
    nsamp=size(data.Data,2);
    
    % find gaps in data, generate vector of indexes, so we can compute a vector
    % of x-axis times by  xt=indexes*deltat;
    % indexes holds the indexes of sample points that actually contain
    % data. This is useful when fitting the timestamps lateron.
    [igap,ngap]=find_gaps(data);
    indexes=generate_indexes(nsamp,igap,ngap);
    
    % generate the reference timestamps using a least squares fit followed
    % by adding an offset too keep timestamps 'causal'
    dejittered_timestamps=estimate_tref_lsq(indexes,data.Timestamps);
    timecorrection=lsl_estimate_timecorrection(data);
    corrected_timestamps=dejittered_timestamps+timecorrection;
end


function fitted_ts=estimate_tref_lsq(x,ts)
    %least squares fit of a line
    coeffs=polyfit(x,ts,1);
    fitted_ts=polyval(coeffs,x);
    % we want causality, i.e. no early arrival of data.
    % The best we can do is assuming the earliest sample is the best we
    % could achieve. This does not take into account the processing time
    % from the capturing of the camera frame until the data are available.
    [mindiff,~]=min(ts-fitted_ts);
    fitted_ts=fitted_ts+mindiff;
    
end

function [igap,ngap]=find_gaps(data)
    pupil_timestamps=data.Data(3,:);
    ts=pupil_timestamps-pupil_timestamps(1);
    diffs=diff(ts);
    deltat=median(diffs);
    thresh=1.5*deltat;
    igap=find(diffs>thresh);
    % gaps are in data at index igap:igap+1 (for all pos)
    ts(igap:igap+1);
    tgap=ts(igap+1)-ts(igap);
    f_ngap=tgap/deltat;
    ngap=round(f_ngap);
    % check that ngap and f_ngap are very equal, i.e. f_ngap are
    % nearly integer values.
    tolerance=0.01;
    if any(abs(ngap-f_ngap)>tolerance)
        warning('find_gaps: possibly inaccurate estimate.');
    end
end

function ind=generate_indexes(n,igap,ngap)
    increments=ones(1,n);
    increments(igap+1)=ngap;
    ind=cumsum(increments);
end


